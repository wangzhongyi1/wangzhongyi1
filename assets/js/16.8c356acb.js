(window.webpackJsonp=window.webpackJsonp||[]).push([[16],{294:function(v,_,t){"use strict";t.r(_);var l=t(14),s=Object(l.a)({},(function(){var v=this,_=v._self._c;return _("ContentSlotsDistributor",{attrs:{"slot-key":v.$parent.slotKey}},[_("h1",{attrs:{id:"javascript-性能优化-2"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#javascript-性能优化-2"}},[v._v("#")]),v._v(" javascript 性能优化(2)")]),v._v(" "),_("h2",{attrs:{id:"性能优化的根本目的"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#性能优化的根本目的"}},[v._v("#")]),v._v(" 性能优化的根本目的")]),v._v(" "),_("p",[v._v("要思考的是用户使用网站的体验如何，而不是我们可以节省多少字节，只有准确感知用户的感受，我们才有必要谈毫秒、字节和请求量等问题")]),v._v(" "),_("h2",{attrs:{id:"针对优化注意事项"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#针对优化注意事项"}},[v._v("#")]),v._v(" 针对优化注意事项")]),v._v(" "),_("ul",[_("li",[v._v("防止过早优化：没必要在刚开始阶段就对一个细节进行放大型的优化，因为这样的成本很高，除了代码可读性方面的东西，甚至还可能会引入更多的bug，所以针对这个问题，我们可以在上线和运营的时候进行监控，当快暴露问题的时候，进行整体优化")]),v._v(" "),_("li",[v._v("本末倒置的关注：网店内容是最重要的，应该查看页面的每个部分，看是否满足网站页面的主要目的，暂时不需要将额外的注意力全部放到一些不关乎本地的东西上。")])]),v._v(" "),_("h2",{attrs:{id:"对于性能的分析"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#对于性能的分析"}},[v._v("#")]),v._v(" 对于性能的分析")]),v._v(" "),_("ul",[_("li",[v._v("使用浏览器的性能分析工具，得到性能分析图标，最著名的就是反向火焰图表，针对浏览器的加载和渲染一目了然")]),v._v(" "),_("li",[v._v("投入使用之前缺乏压力测试和性能测试")])]),v._v(" "),_("h2",{attrs:{id:"性能优化-从用户输入网站到客户端呈现-一步一步优化"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#性能优化-从用户输入网站到客户端呈现-一步一步优化"}},[v._v("#")]),v._v(" 性能优化（从用户输入网站到客户端呈现，一步一步优化）")]),v._v(" "),_("ol",[_("li",[_("p",[v._v("输入网址 --- 告诉浏览器你要去哪里")])]),v._v(" "),_("li",[_("p",[v._v("浏览器查找DNS --- 网络世界是IP地址的世界，DNS就是IP地址的别名。从本地DNS到最顶级DNS一步一步的往上爬，直到命中需要访问的IP地址")])])]),v._v(" "),_("ul",[_("li",[v._v("DNS预解析 --- 使用CDN缓存，加快解析CDN寻找到目标地址（dns-prefetch）")])]),v._v(" "),_("ol",{attrs:{start:"3"}},[_("li",[v._v("客户端和服务器建立连接 --- 建立TCP安全通道，3次握手")])]),v._v(" "),_("ul",[_("li",[v._v("CDN加速 --- 使用内容分发网络，让用户更快的获取到所要的内容")]),v._v(" "),_("li",[v._v("启用压缩 --- 在http协议中，使用类似Gzip压缩的方案")]),v._v(" "),_("li",[v._v("使用HTTP2.0协议 --- http2.0 针对 1.0 优化了很多东西，包括多路复用，头压缩等等，使得传输更快")])]),v._v(" "),_("ol",{attrs:{start:"4"}},[_("li",[v._v("浏览器发送http请求 --- 默认长连接（复用一个tcp通道，短连接：每次连接完就销毁）")])]),v._v(" "),_("ul",[_("li",[v._v("减少http请求 -- 每个请求从创建到销毁都会消耗很多资源和时间，减少请求就可以相对来说更快展示内容\n"),_("ul",[_("li",[v._v("合并压缩css文件和js文件")]),v._v(" "),_("li",[v._v("针对图片，可将图片进行合并然后下载，通过 css Sprites 切割展示（控制大小，太大反而适得其反）")])])]),v._v(" "),_("li",[v._v("使用http缓存 -- 换成原则：越多越好，越久越好。让客户端发送更少请求，直接从本地获取，加快性能")]),v._v(" "),_("li",[v._v("减少cookie请求 -- 针对非必要数据（静态资源）请求，进行跨域隔离，减少传输内容大小")]),v._v(" "),_("li",[v._v("预加载请求 -- 针对一些业务中场景可预加载的内容，提前加载，在之后的用户操作中更少的请求，更快的响应")]),v._v(" "),_("li",[v._v("选择get和post -- 在http定义的时候，get本质上就是获取数据，post是发送数据。get可以在一个TCP报文完成请求，但是post要先发header，再发送数据")]),v._v(" "),_("li",[v._v("缓存方案选型 -- 递进式缓存更新（防止一次性丢失大量缓存，导致负载骤多）")])]),v._v(" "),_("ol",{attrs:{start:"5"}},[_("li",[v._v("服务器响应请求 -- tomcat、IIS等服务器通过本地映射文件关系找到地址或通过数据库查询数据，处理完后返回浏览器")])]),v._v(" "),_("ul",[_("li",[v._v("后端框架选项 -- 更快的响应，前端更快的操作")]),v._v(" "),_("li",[v._v("数据库选项和优化 -- 更快的响应，前端更快的操作")])]),v._v(" "),_("ol",{attrs:{start:"6"}},[_("li",[v._v("浏览器接受响应 -- 浏览器根据报文头里面的数据进行不同的响应处理")])]),v._v(" "),_("ul",[_("li",[v._v("解耦第三方依赖 -- 越多的第三方的不确定因素，会导致web的不稳定性和不确定性")]),v._v(" "),_("li",[v._v("避免404资源 -- 请求资源不到浪费了从请求到接受的所有资源")])]),v._v(" "),_("ol",{attrs:{start:"7"}},[_("li",[v._v("浏览器渲染顺序")])]),v._v(" "),_("ul",[_("li",[v._v("HTML解析，开始构建dom树")]),v._v(" "),_("li",[v._v("外部脚本和样式表加载完毕\n"),_("ul",[_("li",[v._v("尽快加载css，首先将CSSOM对象渲染出来，然后进行页面渲染，否则导致页面闪屏，用户体验差")]),v._v(" "),_("li",[v._v("css选择器是从右往左解析的，所以类似"),_("code",[v._v("#test a {color: #333}")]),v._v("，css解析器会查找所有 a标签 的祖先节点，所以效率不是那么高")]),v._v(" "),_("li",[v._v("在css的媒体查询中，最好不要直接和任何css规则相关。最好写到link标签中，告诉浏览器，只有在这个媒介下，加载指定这个css")])])]),v._v(" "),_("li",[v._v("脚本在文档内解析并执行\n"),_("ul",[_("li",[v._v("按需加载脚本，例如现在的 webpack 就可以打包和按需加载 js脚本")]),v._v(" "),_("li",[v._v("将脚本标记为异步，不阻塞页面渲染，获得最佳启动，保证无关主要的脚本不会阻塞页面")]),v._v(" "),_("li",[v._v("慎重选型框架和类库，避免只是用类库和框架的一个功能或函数，而引入整个文件")])])]),v._v(" "),_("li",[v._v("HTML DOM 完全构建起来\n"),_("ul",[_("li",[v._v("DOM 的多个读操作（或多个写操作），应该放在一起。原则：统一读、统一写")])])]),v._v(" "),_("li",[v._v("图片和外部内容加载\n"),_("ul",[_("li",[v._v("对多媒体内容进行适当优化，包括恰当使用文件格式，文件处理，渐进式渲染等")]),v._v(" "),_("li",[v._v("避免空的src，空的src仍然会发送请求到服务器")]),v._v(" "),_("li",[v._v("避免在 html 内容中缩放图片，如果你需要使用小图，则直接使用小图")])])]),v._v(" "),_("li",[v._v("网页完成加载\n"),_("ul",[_("li",[v._v("服务端渲染，特别针对首屏加载很重要的网址，可以考虑这个方案。后端渲染结束，前端接管展示")])])])]),v._v(" "),_("h3",{attrs:{id:"以下为代码层面的优化"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#以下为代码层面的优化"}},[v._v("#")]),v._v(" 以下为代码层面的优化")]),v._v(" "),_("ol",[_("li",[v._v("针对首屏展示优化")])]),v._v(" "),_("ul",[_("li",[v._v("图片懒加载，针对展示只加载第一屏，等用户进行滚动的时候再进行加载。")]),v._v(" "),_("li",[v._v("浏览器本地缓存模块，可以通过按模块去划分，将页面的模块缓存到localStorage中，每次请求核对模块版本号，丢失或者版本不一致重新请求，否则直接从本地拿")])]),v._v(" "),_("ol",{attrs:{start:"2"}},[_("li",[v._v("javascript优化")])]),v._v(" "),_("ul",[_("li",[v._v("减少对dom节点的查询，因为每次都会重新去索引这个集合或者元素。或者查询一次缓存起来，以待接下来使用")]),v._v(" "),_("li",[v._v("进行js操作DOM的时候，考虑清楚页面的回流和重绘，因为这些操作相对来说十分损耗性能")]),v._v(" "),_("li",[v._v("避免使用 eval 和 Function 构造，因为解析器会将这些内容先转换成可执行代码，然后再进行接下来的操作")]),v._v(" "),_("li",[v._v("减少作用域链的查询，如果一个闭包函数使用到全局作用域的数据，那么每次局部作用域都会一层一层爬到顶层作用域获取数据")]),v._v(" "),_("li",[v._v("数据访问，对非引用类型数据访问和局部变量的访问是最快的。所以如果对引用类型的成员访问超过一次，则缓存")]),v._v(" "),_("li",[v._v("将前端可能会使用的一些算法函数写的更优，在时间和空间复杂度上寻找一个最优方案")]),v._v(" "),_("li",[v._v("去除重复加载同一模块脚本")]),v._v(" "),_("li",[v._v("智能事件处理，比如在一个div下有10个按钮，可以在冒泡过程中捕获这个事件源，然后注册")])]),v._v(" "),_("ol",{attrs:{start:"3"}},[_("li",[v._v("css优化")])]),v._v(" "),_("ul",[_("li",[v._v("删除无用规则")]),v._v(" "),_("li",[v._v("内联关键css")]),v._v(" "),_("li",[v._v("避免@import和Base64")]),v._v(" "),_("li",[v._v("启用高性价比属性（如：opacity vs rgba()）")]),v._v(" "),_("li",[v._v("避免重复性工作")]),v._v(" "),_("li",[v._v("不要一条一条改变样式，而要通过改变css，或者cssText属性，一次性改变样式")]),v._v(" "),_("li",[v._v("可将元素设置为 "),_("code",[v._v("display: noe")]),v._v("，然后N次操作，最后恢复显示")]),v._v(" "),_("li",[v._v("position属性为absolute或fixed的元素，回流的开销会比较小，因为不用考虑它对其他元素的影响")])]),v._v(" "),_("ol",{attrs:{start:"4"}},[_("li",[v._v("图片优化（网络请求中80%都是静态资源的请求）")])]),v._v(" "),_("ul",[_("li",[v._v("图片正确格式的选择")]),v._v(" "),_("li",[v._v("图片尺寸的选择，在低分辨率等情况下考虑降级处理（考虑兼容式图片）")]),v._v(" "),_("li",[v._v("使用正确的工具进行优化（有损压缩，无损压缩）")]),v._v(" "),_("li",[v._v("能用css处理的，优先考虑css实现（阴影、滤镜等）")]),v._v(" "),_("li",[v._v("正确使用data url，比如说多地使用，不建议data url，可考虑缓存")]),v._v(" "),_("li",[v._v("考虑图片懒加载和元素可见性加载方案")]),v._v(" "),_("li",[v._v("图片的预加载，在正确的合理的设计节点进行图片的预加载")])]),v._v(" "),_("h2",{attrs:{id:"总结"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#总结"}},[v._v("#")]),v._v(" 总结")]),v._v(" "),_("p",[v._v("所有性能优化总结为三个层面优化：物理层面，设计层面，代码层面")]),v._v(" "),_("p",[v._v("注：设计层优化最主要的核心：衡量如何花费最少代价实现页面功能")])])}),[],!1,null,null,null);_.default=s.exports}}]);