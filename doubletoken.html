<!DOCTYPE html>
<html lang="en-US">
  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width,initial-scale=1">
    <title>前端双token实现无感刷新 | 目录</title>
    <meta name="generator" content="VuePress 1.9.9">
    
    <meta name="description" content="基于vuepress的博客文档">
    
    <link rel="preload" href="/wangzhongyi1/assets/css/0.styles.47dc8b09.css" as="style"><link rel="preload" href="/wangzhongyi1/assets/js/app.bdc5d73c.js" as="script"><link rel="preload" href="/wangzhongyi1/assets/js/2.6a967e2a.js" as="script"><link rel="preload" href="/wangzhongyi1/assets/js/8.fcf52d9c.js" as="script"><link rel="prefetch" href="/wangzhongyi1/assets/js/10.9760eba6.js"><link rel="prefetch" href="/wangzhongyi1/assets/js/11.8abefe28.js"><link rel="prefetch" href="/wangzhongyi1/assets/js/12.5c0b4704.js"><link rel="prefetch" href="/wangzhongyi1/assets/js/13.c930b9f7.js"><link rel="prefetch" href="/wangzhongyi1/assets/js/14.629be620.js"><link rel="prefetch" href="/wangzhongyi1/assets/js/15.901751e1.js"><link rel="prefetch" href="/wangzhongyi1/assets/js/16.2f8c3543.js"><link rel="prefetch" href="/wangzhongyi1/assets/js/17.92fd3586.js"><link rel="prefetch" href="/wangzhongyi1/assets/js/18.0713e7e9.js"><link rel="prefetch" href="/wangzhongyi1/assets/js/19.3524edc5.js"><link rel="prefetch" href="/wangzhongyi1/assets/js/3.8bd1ad5b.js"><link rel="prefetch" href="/wangzhongyi1/assets/js/4.19d633a5.js"><link rel="prefetch" href="/wangzhongyi1/assets/js/5.a40f3a23.js"><link rel="prefetch" href="/wangzhongyi1/assets/js/6.f8da928a.js"><link rel="prefetch" href="/wangzhongyi1/assets/js/7.09fb6d22.js"><link rel="prefetch" href="/wangzhongyi1/assets/js/9.33202e36.js">
    <link rel="stylesheet" href="/wangzhongyi1/assets/css/0.styles.47dc8b09.css">
  </head>
  <body>
    <div id="app" data-server-rendered="true"><div class="theme-container"><header class="navbar"><div class="sidebar-button"><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" role="img" viewBox="0 0 448 512" class="icon"><path fill="currentColor" d="M436 124H12c-6.627 0-12-5.373-12-12V80c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12zm0 160H12c-6.627 0-12-5.373-12-12v-32c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12zm0 160H12c-6.627 0-12-5.373-12-12v-32c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12z"></path></svg></div> <a href="/wangzhongyi1/" class="home-link router-link-active"><!----> <span class="site-name">目录</span></a> <div class="links"><div class="search-box"><input aria-label="Search" autocomplete="off" spellcheck="false" value=""> <!----></div> <nav class="nav-links can-hide"><div class="nav-item"><a href="/wangzhongyi1/" class="nav-link">
  Home
</a></div> <!----></nav></div></header> <div class="sidebar-mask"></div> <aside class="sidebar"><nav class="nav-links"><div class="nav-item"><a href="/wangzhongyi1/" class="nav-link">
  Home
</a></div> <!----></nav>  <ul class="sidebar-links"><li><a href="/wangzhongyi1/" aria-current="page" class="sidebar-link">大前端团队规划</a></li><li><a href="/wangzhongyi1/devstandard.html" class="sidebar-link">前端开发规范</a></li><li><a href="/wangzhongyi1/checklist.html" class="sidebar-link">前端代码走查CHECKLIST</a></li><li><a href="/wangzhongyi1/gitusage.html" class="sidebar-link">git 日常使用</a></li><li><a href="/wangzhongyi1/gitstandard.html" class="sidebar-link">git 提交规范</a></li><li><a href="/wangzhongyi1/gitmergestandard.html" class="sidebar-link">git 分支合并规范</a></li><li><a href="/wangzhongyi1/jscommonerror.html" class="sidebar-link">前端常见报错类型与解决方案</a></li><li><a href="/wangzhongyi1/htmlstandard.html" class="sidebar-link">HTML 规范</a></li><li><a href="/wangzhongyi1/jsperformance.html" class="sidebar-link">javascript 性能优化</a></li><li><a href="/wangzhongyi1/jsperformance2.html" class="sidebar-link">javascript 性能优化(2)</a></li><li><a href="/wangzhongyi1/npmprivateservebuild.html" class="sidebar-link">npm私服搭建和项目发布</a></li><li><a href="/wangzhongyi1/doubletoken.html" aria-current="page" class="active sidebar-link">前端双token实现无感刷新</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a href="/wangzhongyi1/doubletoken.html#为什么要用双token无感刷新-它解决了什么问题" class="sidebar-link">为什么要用双Token无感刷新，它解决了什么问题？</a></li><li class="sidebar-sub-header"><a href="/wangzhongyi1/doubletoken.html#这两个token都是干什么的-具体过程是怎么样的" class="sidebar-link">这两个Token都是干什么的？具体过程是怎么样的？</a></li></ul></li><li><a href="/wangzhongyi1/front-moniter-01.html" class="sidebar-link">前端监控-错误监控原理</a></li></ul> </aside> <main class="page"> <div class="theme-default-content content__default"><h1 id="前端双token实现无感刷新"><a href="#前端双token实现无感刷新" class="header-anchor">#</a> 前端双token实现无感刷新</h1> <p><img src="/wangzhongyi1/assets/img/2-token.1ccc4716.png" alt=""></p> <h2 id="为什么要用双token无感刷新-它解决了什么问题"><a href="#为什么要用双token无感刷新-它解决了什么问题" class="header-anchor">#</a> 为什么要用双Token无感刷新，它解决了什么问题？</h2> <p>为了保证安全性，后端设置的Token不可能长期有效，过了一段时间Token就会失效。而发送网络请求的过程又是需要携带Token的，</p> <p>一旦Token失效，用户就要重新登录，这样用户可能需要频繁登录，体验不好。为了解决这个问题，采取双Token（Access_Token，Refresh_Token）</p> <p>无感刷新，用户完全感知不到Token的变化，但实际上，Token已经刷新了</p> <h2 id="这两个token都是干什么的-具体过程是怎么样的"><a href="#这两个token都是干什么的-具体过程是怎么样的" class="header-anchor">#</a> 这两个Token都是干什么的？具体过程是怎么样的？</h2> <h3 id="前置条件"><a href="#前置条件" class="header-anchor">#</a> 前置条件</h3> <p>后端提供一个刷新Token的接口，假设是A接口。</p> <ul><li>两个Token的作用：
<ul><li>Access_Token：用于鉴定用户身份，即每次发送网络请求都需要携带这个Access_Token</li> <li>Refresh_Token：用户刷新Access_Token，即调用A接口需要携带Refresh_Token，用它换得最新的Access_Token</li></ul></li></ul> <h3 id="过程"><a href="#过程" class="header-anchor">#</a> 过程</h3> <p>1、用户登录客户端之后，接收后端发送的两个Token，前端把他们存在LocalStorage或vuex中
2、Access_Token未过期时，发送网络请求携带Access_Token即可
3、Access_Token过期后，前端携带Refresh_Token调用A接口得到新的Access_Token，把新的Access_Token替换旧的Access_Token存储起来</p> <h3 id="具体如何实现"><a href="#具体如何实现" class="header-anchor">#</a> 具体如何实现？</h3> <p>首先明确一点，这个无感刷新的逻辑要写在 axios 的响应拦截器里面</p> <ul><li>说明
<ul><li>isRefreshing 用于标记是否正在调用 tokenRefreshAPI，相当于一把锁</li> <li>request队列用于存储 tokenRefreshAPI 响应期间进入的 promise 对象</li></ul></li></ul> <div class="language-js extra-class"><pre class="language-js"><code><span class="token keyword">var</span> isRefreshing <span class="token operator">=</span> <span class="token boolean">false</span><span class="token punctuation">;</span>
<span class="token keyword">var</span> requests <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">;</span>

<span class="token comment">// service 是自己配置的 axios，在 axios 里面配置一些基本设置，比如：baseURL, timeout, headers的Authorization（一般是 &quot;Bearer&quot; + Access_Token）</span>
service<span class="token punctuation">.</span>interceptors<span class="token punctuation">.</span>response<span class="token punctuation">.</span><span class="token function">use</span><span class="token punctuation">(</span>
    <span class="token parameter">res</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span>
        <span class="token comment">// accesstoken 超时</span>
        <span class="token keyword">if</span> <span class="token punctuation">(</span>res<span class="token punctuation">.</span>data<span class="token punctuation">.</span>result_status <span class="token operator">===</span> <span class="token number">30002</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
            <span class="token comment">// 记录当前 res</span>
            <span class="token keyword">let</span> response <span class="token operator">=</span> res<span class="token punctuation">;</span>
            <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span>isRefreshing<span class="token punctuation">)</span> <span class="token punctuation">{</span>
                isRefreshing <span class="token operator">=</span> <span class="token boolean">true</span><span class="token punctuation">;</span>
                <span class="token keyword">return</span> <span class="token function">tokenRefreshAPI</span><span class="token punctuation">(</span><span class="token punctuation">{</span>
                    <span class="token literal-property property">token</span><span class="token operator">:</span> <span class="token constant">JSON</span><span class="token punctuation">.</span><span class="token function">parse</span><span class="token punctuation">(</span>window<span class="token punctuation">.</span>localStorage<span class="token punctuation">.</span><span class="token function">getItem</span><span class="token punctuation">(</span><span class="token string">'token'</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
                <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">then</span><span class="token punctuation">(</span><span class="token parameter">r</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span>
                    <span class="token comment">// refreshToken 没过期，刷新成功</span>
                    <span class="token keyword">if</span> <span class="token punctuation">(</span>r<span class="token punctuation">.</span>data<span class="token punctuation">.</span>result_status <span class="token operator">===</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
                        <span class="token comment">// 重新设置 token</span>
                        window<span class="token punctuation">.</span>localStorage<span class="token punctuation">.</span><span class="token function">setTtem</span><span class="token punctuation">(</span><span class="token string">'token'</span><span class="token punctuation">,</span> <span class="token constant">JSON</span><span class="token punctuation">.</span><span class="token function">stringify</span><span class="token punctuation">(</span>r<span class="token punctuation">.</span>data<span class="token punctuation">.</span>token<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
                        <span class="token comment">// 执行失效的函数</span>
                        requests<span class="token punctuation">.</span><span class="token function">forEach</span><span class="token punctuation">(</span><span class="token parameter">cb</span> <span class="token operator">=&gt;</span> <span class="token function">cb</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
                        requests <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">;</span>
                        <span class="token comment">// 因为第一个请求是没有进 requests 队列的，所以需要在这个重新发起请求</span>
                        <span class="token keyword">return</span> <span class="token function">service</span><span class="token punctuation">(</span>response<span class="token punctuation">.</span>config<span class="token punctuation">)</span><span class="token punctuation">;</span>
                    <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span>r<span class="token punctuation">.</span>data<span class="token punctuation">.</span>result_status <span class="token operator">===</span> <span class="token number">30011</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
                        <span class="token comment">// refresh_token 过期，重新登录</span>
                        window<span class="token punctuation">.</span>localStorage<span class="token punctuation">.</span><span class="token function">clear</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
                        router<span class="token punctuation">.</span><span class="token function">push</span><span class="token punctuation">(</span><span class="token string">'/login'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
                    <span class="token punctuation">}</span>
                <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">finally</span><span class="token punctuation">(</span><span class="token parameter">_</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span>
                    isRefreshing <span class="token operator">=</span> <span class="token boolean">true</span><span class="token punctuation">;</span>
                <span class="token punctuation">}</span><span class="token punctuation">)</span>；
            <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>
                console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">'token 过期，剩余请求存入队列'</span><span class="token punctuation">,</span> axiosConfig<span class="token punctuation">.</span>url<span class="token punctuation">)</span><span class="token punctuation">;</span>
                <span class="token comment">// 返回未执行 resolve 的 Promise</span>
                <span class="token keyword">return</span> <span class="token keyword">new</span> <span class="token class-name">Promise</span><span class="token punctuation">(</span><span class="token parameter">resolve</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span>
                    <span class="token comment">// 用函数形式将 resolve 存入，等待刷新后再执行</span>
                    requests<span class="token punctuation">.</span><span class="token function">push</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token function">resolve</span><span class="token punctuation">(</span><span class="token function">sercice</span><span class="token punctuation">(</span>axiosConfig<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
                <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
            <span class="token punctuation">}</span>
        <span class="token punctuation">}</span>
        <span class="token keyword">return</span> res<span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">)</span>
</code></pre></div><h3 id="注意"><a href="#注意" class="header-anchor">#</a> 注意</h3> <p>1、在 Access_Token 过期后，可能会短时间发送很多个网络请求，这些网络请求，在拦截器内会全部请求刷新Token，这样显然是不合理的，
其实只要刷新一次就够了，所以给刷新Token这部操作加个锁🔒，这也是为什么要设置 isRefreshing 的原因。</p> <p>2、在请求刷新Token的响应时间内，可能会有多个网络请求到达，我们又暂时没有办法处理这些请求，所以我们把这些请求用 Promise 封装存储到 requests 队列中，
等刷新好 Token 之后再依次处理这些 promise 对象。</p></div> <footer class="page-edit"><!----> <!----></footer> <div class="page-nav"><p class="inner"><span class="prev">
      ←
      <a href="/wangzhongyi1/npmprivateservebuild.html" class="prev">
        npm私服搭建和项目发布
      </a></span> <span class="next"><a href="/wangzhongyi1/front-moniter-01.html">
        前端监控-错误监控原理
      </a>
      →
    </span></p></div> </main></div><div class="global-ui"></div></div>
    <script src="/wangzhongyi1/assets/js/app.bdc5d73c.js" defer></script><script src="/wangzhongyi1/assets/js/2.6a967e2a.js" defer></script><script src="/wangzhongyi1/assets/js/8.fcf52d9c.js" defer></script>
  </body>
</html>
