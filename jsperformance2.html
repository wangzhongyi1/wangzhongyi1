<!DOCTYPE html>
<html lang="en-US">
  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width,initial-scale=1">
    <title>javascript 性能优化(2) | 目录</title>
    <meta name="generator" content="VuePress 1.9.9">
    
    <meta name="description" content="基于vuepress的博客文档">
    
    <link rel="preload" href="/wangzhongyi1/assets/css/0.styles.9c75b076.css" as="style"><link rel="preload" href="/wangzhongyi1/assets/js/app.9a238c43.js" as="script"><link rel="preload" href="/wangzhongyi1/assets/js/2.c8cb3ded.js" as="script"><link rel="preload" href="/wangzhongyi1/assets/js/16.8c356acb.js" as="script"><link rel="prefetch" href="/wangzhongyi1/assets/js/10.01890840.js"><link rel="prefetch" href="/wangzhongyi1/assets/js/11.729d5a52.js"><link rel="prefetch" href="/wangzhongyi1/assets/js/12.28a4f1de.js"><link rel="prefetch" href="/wangzhongyi1/assets/js/13.2cc8e06f.js"><link rel="prefetch" href="/wangzhongyi1/assets/js/14.dd975692.js"><link rel="prefetch" href="/wangzhongyi1/assets/js/15.804e5c09.js"><link rel="prefetch" href="/wangzhongyi1/assets/js/17.cd338e41.js"><link rel="prefetch" href="/wangzhongyi1/assets/js/3.46563f66.js"><link rel="prefetch" href="/wangzhongyi1/assets/js/4.3338103e.js"><link rel="prefetch" href="/wangzhongyi1/assets/js/5.a434e9b9.js"><link rel="prefetch" href="/wangzhongyi1/assets/js/6.5681fdb3.js"><link rel="prefetch" href="/wangzhongyi1/assets/js/7.c8654701.js"><link rel="prefetch" href="/wangzhongyi1/assets/js/8.da7cd628.js"><link rel="prefetch" href="/wangzhongyi1/assets/js/9.552fa6f8.js">
    <link rel="stylesheet" href="/wangzhongyi1/assets/css/0.styles.9c75b076.css">
  </head>
  <body>
    <div id="app" data-server-rendered="true"><div class="theme-container"><header class="navbar"><div class="sidebar-button"><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" role="img" viewBox="0 0 448 512" class="icon"><path fill="currentColor" d="M436 124H12c-6.627 0-12-5.373-12-12V80c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12zm0 160H12c-6.627 0-12-5.373-12-12v-32c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12zm0 160H12c-6.627 0-12-5.373-12-12v-32c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12z"></path></svg></div> <a href="/wangzhongyi1/" class="home-link router-link-active"><!----> <span class="site-name">目录</span></a> <div class="links"><div class="search-box"><input aria-label="Search" autocomplete="off" spellcheck="false" value=""> <!----></div> <nav class="nav-links can-hide"><div class="nav-item"><a href="/wangzhongyi1/" class="nav-link">
  Home
</a></div> <!----></nav></div></header> <div class="sidebar-mask"></div> <aside class="sidebar"><nav class="nav-links"><div class="nav-item"><a href="/wangzhongyi1/" class="nav-link">
  Home
</a></div> <!----></nav>  <ul class="sidebar-links"><li><a href="/wangzhongyi1/" aria-current="page" class="sidebar-link">大前端团队规划</a></li><li><a href="/wangzhongyi1/devstandard.html" class="sidebar-link">前端开发规范</a></li><li><a href="/wangzhongyi1/checklist.html" class="sidebar-link">前端代码走查CHECKLIST</a></li><li><a href="/wangzhongyi1/gitusage.html" class="sidebar-link">git 日常使用</a></li><li><a href="/wangzhongyi1/gitstandard.html" class="sidebar-link">git 提交规范</a></li><li><a href="/wangzhongyi1/gitmergestandard.html" class="sidebar-link">git 分支合并规范</a></li><li><a href="/wangzhongyi1/jscommonerror.html" class="sidebar-link">前端常见报错类型与解决方案</a></li><li><a href="/wangzhongyi1/htmlstandard.html" class="sidebar-link">HTML 规范</a></li><li><a href="/wangzhongyi1/jsperformance.html" class="sidebar-link">javascript 性能优化</a></li><li><a href="/wangzhongyi1/jsperformance2.html" aria-current="page" class="active sidebar-link">javascript 性能优化(2)</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a href="/wangzhongyi1/jsperformance2.html#性能优化的根本目的" class="sidebar-link">性能优化的根本目的</a></li><li class="sidebar-sub-header"><a href="/wangzhongyi1/jsperformance2.html#针对优化注意事项" class="sidebar-link">针对优化注意事项</a></li><li class="sidebar-sub-header"><a href="/wangzhongyi1/jsperformance2.html#对于性能的分析" class="sidebar-link">对于性能的分析</a></li><li class="sidebar-sub-header"><a href="/wangzhongyi1/jsperformance2.html#性能优化-从用户输入网站到客户端呈现-一步一步优化" class="sidebar-link">性能优化（从用户输入网站到客户端呈现，一步一步优化）</a></li><li class="sidebar-sub-header"><a href="/wangzhongyi1/jsperformance2.html#总结" class="sidebar-link">总结</a></li></ul></li><li><a href="/wangzhongyi1/npmprivateservebuild.html" class="sidebar-link">npm私服搭建和项目发布</a></li></ul> </aside> <main class="page"> <div class="theme-default-content content__default"><h1 id="javascript-性能优化-2"><a href="#javascript-性能优化-2" class="header-anchor">#</a> javascript 性能优化(2)</h1> <h2 id="性能优化的根本目的"><a href="#性能优化的根本目的" class="header-anchor">#</a> 性能优化的根本目的</h2> <p>要思考的是用户使用网站的体验如何，而不是我们可以节省多少字节，只有准确感知用户的感受，我们才有必要谈毫秒、字节和请求量等问题</p> <h2 id="针对优化注意事项"><a href="#针对优化注意事项" class="header-anchor">#</a> 针对优化注意事项</h2> <ul><li>防止过早优化：没必要在刚开始阶段就对一个细节进行放大型的优化，因为这样的成本很高，除了代码可读性方面的东西，甚至还可能会引入更多的bug，所以针对这个问题，我们可以在上线和运营的时候进行监控，当快暴露问题的时候，进行整体优化</li> <li>本末倒置的关注：网店内容是最重要的，应该查看页面的每个部分，看是否满足网站页面的主要目的，暂时不需要将额外的注意力全部放到一些不关乎本地的东西上。</li></ul> <h2 id="对于性能的分析"><a href="#对于性能的分析" class="header-anchor">#</a> 对于性能的分析</h2> <ul><li>使用浏览器的性能分析工具，得到性能分析图标，最著名的就是反向火焰图表，针对浏览器的加载和渲染一目了然</li> <li>投入使用之前缺乏压力测试和性能测试</li></ul> <h2 id="性能优化-从用户输入网站到客户端呈现-一步一步优化"><a href="#性能优化-从用户输入网站到客户端呈现-一步一步优化" class="header-anchor">#</a> 性能优化（从用户输入网站到客户端呈现，一步一步优化）</h2> <ol><li><p>输入网址 --- 告诉浏览器你要去哪里</p></li> <li><p>浏览器查找DNS --- 网络世界是IP地址的世界，DNS就是IP地址的别名。从本地DNS到最顶级DNS一步一步的往上爬，直到命中需要访问的IP地址</p></li></ol> <ul><li>DNS预解析 --- 使用CDN缓存，加快解析CDN寻找到目标地址（dns-prefetch）</li></ul> <ol start="3"><li>客户端和服务器建立连接 --- 建立TCP安全通道，3次握手</li></ol> <ul><li>CDN加速 --- 使用内容分发网络，让用户更快的获取到所要的内容</li> <li>启用压缩 --- 在http协议中，使用类似Gzip压缩的方案</li> <li>使用HTTP2.0协议 --- http2.0 针对 1.0 优化了很多东西，包括多路复用，头压缩等等，使得传输更快</li></ul> <ol start="4"><li>浏览器发送http请求 --- 默认长连接（复用一个tcp通道，短连接：每次连接完就销毁）</li></ol> <ul><li>减少http请求 -- 每个请求从创建到销毁都会消耗很多资源和时间，减少请求就可以相对来说更快展示内容
<ul><li>合并压缩css文件和js文件</li> <li>针对图片，可将图片进行合并然后下载，通过 css Sprites 切割展示（控制大小，太大反而适得其反）</li></ul></li> <li>使用http缓存 -- 换成原则：越多越好，越久越好。让客户端发送更少请求，直接从本地获取，加快性能</li> <li>减少cookie请求 -- 针对非必要数据（静态资源）请求，进行跨域隔离，减少传输内容大小</li> <li>预加载请求 -- 针对一些业务中场景可预加载的内容，提前加载，在之后的用户操作中更少的请求，更快的响应</li> <li>选择get和post -- 在http定义的时候，get本质上就是获取数据，post是发送数据。get可以在一个TCP报文完成请求，但是post要先发header，再发送数据</li> <li>缓存方案选型 -- 递进式缓存更新（防止一次性丢失大量缓存，导致负载骤多）</li></ul> <ol start="5"><li>服务器响应请求 -- tomcat、IIS等服务器通过本地映射文件关系找到地址或通过数据库查询数据，处理完后返回浏览器</li></ol> <ul><li>后端框架选项 -- 更快的响应，前端更快的操作</li> <li>数据库选项和优化 -- 更快的响应，前端更快的操作</li></ul> <ol start="6"><li>浏览器接受响应 -- 浏览器根据报文头里面的数据进行不同的响应处理</li></ol> <ul><li>解耦第三方依赖 -- 越多的第三方的不确定因素，会导致web的不稳定性和不确定性</li> <li>避免404资源 -- 请求资源不到浪费了从请求到接受的所有资源</li></ul> <ol start="7"><li>浏览器渲染顺序</li></ol> <ul><li>HTML解析，开始构建dom树</li> <li>外部脚本和样式表加载完毕
<ul><li>尽快加载css，首先将CSSOM对象渲染出来，然后进行页面渲染，否则导致页面闪屏，用户体验差</li> <li>css选择器是从右往左解析的，所以类似<code>#test a {color: #333}</code>，css解析器会查找所有 a标签 的祖先节点，所以效率不是那么高</li> <li>在css的媒体查询中，最好不要直接和任何css规则相关。最好写到link标签中，告诉浏览器，只有在这个媒介下，加载指定这个css</li></ul></li> <li>脚本在文档内解析并执行
<ul><li>按需加载脚本，例如现在的 webpack 就可以打包和按需加载 js脚本</li> <li>将脚本标记为异步，不阻塞页面渲染，获得最佳启动，保证无关主要的脚本不会阻塞页面</li> <li>慎重选型框架和类库，避免只是用类库和框架的一个功能或函数，而引入整个文件</li></ul></li> <li>HTML DOM 完全构建起来
<ul><li>DOM 的多个读操作（或多个写操作），应该放在一起。原则：统一读、统一写</li></ul></li> <li>图片和外部内容加载
<ul><li>对多媒体内容进行适当优化，包括恰当使用文件格式，文件处理，渐进式渲染等</li> <li>避免空的src，空的src仍然会发送请求到服务器</li> <li>避免在 html 内容中缩放图片，如果你需要使用小图，则直接使用小图</li></ul></li> <li>网页完成加载
<ul><li>服务端渲染，特别针对首屏加载很重要的网址，可以考虑这个方案。后端渲染结束，前端接管展示</li></ul></li></ul> <h3 id="以下为代码层面的优化"><a href="#以下为代码层面的优化" class="header-anchor">#</a> 以下为代码层面的优化</h3> <ol><li>针对首屏展示优化</li></ol> <ul><li>图片懒加载，针对展示只加载第一屏，等用户进行滚动的时候再进行加载。</li> <li>浏览器本地缓存模块，可以通过按模块去划分，将页面的模块缓存到localStorage中，每次请求核对模块版本号，丢失或者版本不一致重新请求，否则直接从本地拿</li></ul> <ol start="2"><li>javascript优化</li></ol> <ul><li>减少对dom节点的查询，因为每次都会重新去索引这个集合或者元素。或者查询一次缓存起来，以待接下来使用</li> <li>进行js操作DOM的时候，考虑清楚页面的回流和重绘，因为这些操作相对来说十分损耗性能</li> <li>避免使用 eval 和 Function 构造，因为解析器会将这些内容先转换成可执行代码，然后再进行接下来的操作</li> <li>减少作用域链的查询，如果一个闭包函数使用到全局作用域的数据，那么每次局部作用域都会一层一层爬到顶层作用域获取数据</li> <li>数据访问，对非引用类型数据访问和局部变量的访问是最快的。所以如果对引用类型的成员访问超过一次，则缓存</li> <li>将前端可能会使用的一些算法函数写的更优，在时间和空间复杂度上寻找一个最优方案</li> <li>去除重复加载同一模块脚本</li> <li>智能事件处理，比如在一个div下有10个按钮，可以在冒泡过程中捕获这个事件源，然后注册</li></ul> <ol start="3"><li>css优化</li></ol> <ul><li>删除无用规则</li> <li>内联关键css</li> <li>避免@import和Base64</li> <li>启用高性价比属性（如：opacity vs rgba()）</li> <li>避免重复性工作</li> <li>不要一条一条改变样式，而要通过改变css，或者cssText属性，一次性改变样式</li> <li>可将元素设置为 <code>display: noe</code>，然后N次操作，最后恢复显示</li> <li>position属性为absolute或fixed的元素，回流的开销会比较小，因为不用考虑它对其他元素的影响</li></ul> <ol start="4"><li>图片优化（网络请求中80%都是静态资源的请求）</li></ol> <ul><li>图片正确格式的选择</li> <li>图片尺寸的选择，在低分辨率等情况下考虑降级处理（考虑兼容式图片）</li> <li>使用正确的工具进行优化（有损压缩，无损压缩）</li> <li>能用css处理的，优先考虑css实现（阴影、滤镜等）</li> <li>正确使用data url，比如说多地使用，不建议data url，可考虑缓存</li> <li>考虑图片懒加载和元素可见性加载方案</li> <li>图片的预加载，在正确的合理的设计节点进行图片的预加载</li></ul> <h2 id="总结"><a href="#总结" class="header-anchor">#</a> 总结</h2> <p>所有性能优化总结为三个层面优化：物理层面，设计层面，代码层面</p> <p>注：设计层优化最主要的核心：衡量如何花费最少代价实现页面功能</p></div> <footer class="page-edit"><!----> <!----></footer> <div class="page-nav"><p class="inner"><span class="prev">
      ←
      <a href="/wangzhongyi1/jsperformance.html" class="prev">
        javascript 性能优化
      </a></span> <span class="next"><a href="/wangzhongyi1/npmprivateservebuild.html">
        npm私服搭建和项目发布
      </a>
      →
    </span></p></div> </main></div><div class="global-ui"></div></div>
    <script src="/wangzhongyi1/assets/js/app.9a238c43.js" defer></script><script src="/wangzhongyi1/assets/js/2.c8cb3ded.js" defer></script><script src="/wangzhongyi1/assets/js/16.8c356acb.js" defer></script>
  </body>
</html>
